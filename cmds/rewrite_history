#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR=$(CDPATH="" cd -- "$(dirname -- "$0")" && pwd)
ROOT_DIR=$(CDPATH="" cd -- "${SCRIPT_DIR}/.." && pwd)
. "${ROOT_DIR}/lib/common"

REPO_DIR="${REPO_DIR:?REPO_DIR is not set}"
REPO_REWRITER_DIR="${REPO_DIR}/.git/repo-rewriter"
HISTORY_CONFIG="${REPO_REWRITER_DIR}/history_config"

EXCLUDE_BEGINNING="###> repo-rewriter ###"
EXCLUDE_ENDING="###< repo-rewriter ###"

# picked ⇄ committed
#    ⇅
# skipped
STATE_PICKED="picked"
STATE_COMMITTED="committed"
STATE_SKIPPED="skipped"

if [[ -s "${HISTORY_CONFIG}" ]]; then
  info "Loading configuration from '${HISTORY_CONFIG}'."
  . "${HISTORY_CONFIG}"
else
  warn "Using default values for configuration."
  ORIGINAL_ROOT="${ORIGINAL_ROOT:-}"
  ORIGINAL_HEAD="${ORIGINAL_HEAD:-refs/heads/main}"
  REWRITTEN_HEAD="${REWRITTEN_HEAD:-refs/heads/rewritten}"
  CURRENT_SHA="${CURRENT_SHA:-}"
  CURRENT_STATE="${CURRENT_STATE:-}"
fi

GIT() {
  git -C "${REPO_DIR}" "$@"
}

list_of_ignored() {
  sanitize() {
    grep -vE -e '^#' -e '^[[:space:]]*$' | sed -E -e 's|^\.?/||' -e 's|/+$||' -e 's|^|/|'
  }

  local excluded=
  if [[ -f "${REPO_DIR}/.gitignore" ]]; then
    excluded="$(sanitize < "${REPO_DIR}/.gitignore" | \
      sed -E -e "s|^|${REPO_DIR}|" | \
      xargs -I'{}' sh -c "test -d '{}' && echo '{}' || true" | \
      sed -E -e "s|(.+)|-not -path '\1/*'|" | \
      paste -s -d' ' -
    )"
  fi

  local dir
  while read -r gitignore; do
    dir=$(dirname "${gitignore}")
    sanitize < "${gitignore}" | xargs -I'{}' sh -c "echo ${dir#"${REPO_DIR}"}{}"
  done < <(eval "find '${REPO_DIR}' -type f -name '.gitignore' ! -empty ${excluded}")
}

update_state() {
  local sha="$1" state="$2"
  sed -E -i '' \
    -e "/^CURRENT_SHA/s/^.+\$/CURRENT_SHA=${sha}/" \
    -e "/^CURRENT_STATE/s/^.+\$/CURRENT_STATE=${state}/" \
    "${HISTORY_CONFIG}"

  CURRENT_SHA="${sha}"
  CURRENT_STATE="${state}"
}

pre_init() {
  info "Checking if it is possible to initiate."
  if [[ -n "${CURRENT_STATE}" ]]; then
    die "Rewritten process was already initiated."
  fi

  info "Checking if ${ORIGINAL_HEAD} exists."
  if ! GIT show-ref --heads --quiet "${ORIGINAL_HEAD}"; then
    die "Original HEAD ${ORIGINAL_HEAD} not exist."
  fi

  info "Checking if history is not linear."
  if [[ $(GIT rev-list --min-parents=2 "${ORIGINAL_HEAD}" | wc -l) -ne 0 ]]; then
    die "History is not linear."
  fi

  info "Setting root repository if another is not specified."
  if [[ -z "${ORIGINAL_ROOT}" ]]; then
    ORIGINAL_ROOT="$(GIT rev-list --max-parents=0 "${ORIGINAL_HEAD}")"
  fi

  info "Checking if they are part of the same history."
  if ! GIT merge-base --is-ancestor "${ORIGINAL_ROOT}" "${ORIGINAL_HEAD}"; then
    die "${ORIGINAL_ROOT} is not an ancestor of ${ORIGINAL_HEAD}."
  fi

  info "Checking if some uncommitted changes exist."
  if ! GIT diff-index --quiet HEAD; then
    die "The index or working tree is dirty."
  fi
}

init() {
  pre_init
  has_flag "--dry-run" "$@" && exit 0

  # Utility preparation
  info "Populating .git/info/exclude with originally ignored files."
  (
    echo "${EXCLUDE_BEGINNING}"
    list_of_ignored
    echo "${EXCLUDE_ENDING}"
  ) >> "${REPO_DIR}/.git/info/exclude"

  info "Creating a folder for repo-rewriter tool if it does not exist."
  mkdir -p "${REPO_REWRITER_DIR}"

  info "Setting the configuration of the rewriting process."
  (
    echo "ORIGINAL_ROOT=${ORIGINAL_ROOT}"
    echo "ORIGINAL_HEAD=${ORIGINAL_HEAD}"
    echo "REWRITTEN_HEAD=${REWRITTEN_HEAD}"
    echo "CURRENT_SHA=${ORIGINAL_ROOT}"
    echo "CURRENT_STATE=${STATE_PICKED}"
  ) > "${HISTORY_CONFIG}"

  # Repository manipulation
  info "Moving HEAD to no reference."
  GIT symbolic-ref HEAD "${REWRITTEN_HEAD}"

  info "Populating the working tree with changes from the root commit."
  GIT read-tree "${ORIGINAL_ROOT}"
  GIT checkout-index -a -f

  info "Removing all other files and empty folders in the working tree."
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"
  find "${REPO_DIR}" -type d -empty -delete

  info "Purifying the index."
  GIT read-tree --empty

  info "Initialization was successful. Root commit was checked out."
}

pre_pick() {
  info "Checking if it is possible to pick the next commit."
  if [[ "${CURRENT_STATE}" != "${STATE_COMMITTED}" && "${CURRENT_STATE}" != "${STATE_SKIPPED}" ]]; then
    die "Cannot pick the next commit. You have already picked the commit."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Checking if there are staged files present."
  if ! GIT diff-index --cached --quiet HEAD; then
    die "There are staged files."
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    die "There are unstaged files."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    die "There are untracked files."
  fi
}

pick() {
  pre_pick
  has_flag "--dry-run" "$@" && exit 0

  info "Checking if the end of history was reached."
  local last
  last="$(sed -En '$p' <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  if [[ "${CURRENT_SHA}" == "$last" ]]; then
    die "End of history reached."
  fi

  info "Getting the next commit."
  local next_sha
  next_sha="$(sed -En "/^${CURRENT_SHA}\$/{n;p;q;}" <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  info "The ${next_sha} commit has taken."

  info "Populating the working tree with changes from the picked commit."
  local tmp
  tmp="$(mktemp)"
  GIT_INDEX_FILE="${tmp}" git -C "${REPO_DIR}" read-tree "${next_sha}"
  GIT_INDEX_FILE="${tmp}" git -C "${REPO_DIR}" checkout-index -a -f
  rm -f "${tmp}"

  info "Updating the rewriting state."
  update_state "${next_sha}" "${STATE_PICKED}"
}

pre_commit() {
  info "Checking if it is possible to make a commit."
  if [[ "${CURRENT_STATE}" != "${STATE_PICKED}" ]]; then
    die "Cannot commit the changes. You have to pick the commit first."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Picking a base to diff the index against."
  local against=HEAD
  if ! GIT rev-parse --verify --quiet HEAD >/dev/null; then
    against=$(GIT hash-object -t tree /dev/null)
  fi

  info "Checking if there are staged files present."
  if GIT diff-index --cached --quiet "${against}" --; then
    die "Nothing to commit."
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    die "There are unstaged files."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    die "There are some untracked files that will be not committed."
  fi
}

commit() {
  pre_commit
  has_flag "--dry-run" "$@" && exit 0

  info "Creating a tree object from the current index."
  local tree_sha
  tree_sha="$(GIT write-tree)"

  info "Extracting all metadata from the original commit."
  local format author_name author_email author_date committer_name committer_email committer_date message
  format="%an%x00%ae%x00%aD%x00%cn%x00%ce%x00%cD%x00%B%x00"
  exec 3< <(GIT rev-list -1 --format="${format}" "${CURRENT_SHA}" | sed '1d')
  IFS= read -r -d '' author_name <&3
  IFS= read -r -d '' author_email <&3
  IFS= read -r -d '' author_date <&3
  IFS= read -r -d '' committer_name <&3
  IFS= read -r -d '' committer_email <&3
  IFS= read -r -d '' committer_date <&3
  IFS= read -r -d '' message <&3
  exec 3<&-

  COMMIT_MESSAGE="${COMMIT_MESSAGE:-"${message}"}"

  info "Extracting a parent commit of rewritten history."
  local commit_cmd
  if GIT rev-parse --verify --quiet HEAD >/dev/null; then
    commit_cmd="GIT commit-tree -p '$(GIT rev-parse HEAD)' '${tree_sha}'"
  else
    commit_cmd="GIT commit-tree '${tree_sha}'"
  fi

  info "Creating a commit with all available metadata."
  local commit_sha
  commit_sha="$(printf '%s' "${COMMIT_MESSAGE}" | \
    GIT_AUTHOR_NAME="${author_name}" \
    GIT_AUTHOR_EMAIL="${author_email}" \
    GIT_AUTHOR_DATE="${author_date}" \
    GIT_COMMITTER_NAME="${committer_name}" \
    GIT_COMMITTER_EMAIL="${committer_email}" \
    GIT_COMMITTER_DATE="${committer_date}" \
    eval "${commit_cmd}"
  )"

  info "Moving the ref to the created commit."
  GIT update-ref "${REWRITTEN_HEAD}" "${commit_sha}"

  info "Updating the rewriting state."
  update_state "${CURRENT_SHA}" "${STATE_COMMITTED}"
}

pre_rollback() {
  info "Checking if it is possible to rollback to the previous commit."
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi

  if [[ "${CURRENT_SHA}" == "${ORIGINAL_ROOT}" ]]; then
    die "Root commit of original history reached. "
  fi
}

rollback() {
  pre_rollback
  has_flag "--dry-run" "$@" && exit 0

  if has_flag "--not-rewritten" "$@"; then
    info "Skipping rollback of rewritten history."
  elif ! GIT rev-list HEAD~1 -1 2> /dev/null; then
    warn "Skipping rollback of rewritten history due to reaching the root."
  else
    info "Getting the previous commit."
    local previous_sha
    previous_sha="$(GIT rev-list HEAD~1 -1)"

    info "Sanitizing the index and populating the working tree with previous commit."
    GIT read-tree "${previous_sha}"
    GIT checkout-index -a -f -u
    GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

    info "Moving the reference to the previous commit."
    GIT update-ref "${REWRITTEN_HEAD}" "${previous_sha}"
  fi

  info "Getting the original previous sha."
  local original_previous_sha
  original_previous_sha="$(sed -En "/^${CURRENT_SHA}\$/{g;p;q;}; h" <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"

  info "Updating the rewriting state."
  update_state "${original_previous_sha}" "${STATE_COMMITTED}"
}

pre_skip() {
  info "Checking if it is possible to skip current commit."
  if [[ "${CURRENT_STATE}" != "${STATE_PICKED}" ]]; then
    die "Cannot skip current commit. You have to pick the commit first."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Picking a base to diff the index against."
  local against=HEAD
  if ! GIT rev-parse --verify --quiet HEAD >/dev/null; then
    against=$(GIT hash-object -t tree /dev/null)
  fi

  info "Checking if there are staged files present."
  if GIT diff-index --cached --quiet "${against}" --; then
    warn "There are some staged files that will be erased."
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    warn "There are unstaged files that will be erased."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    warn "There are some untracked files that will be erased."
  fi
}

skip() {
  pre_skip
  has_flag "--dry-run" "$@" && exit 0

  info "Reading the current commit."
  local current_sha
  read -r current_sha < <(GIT rev-list HEAD -1)

  info "Sanitizing the index and populating the working tree with current HEAD."
  GIT read-tree "${current_sha}"
  GIT checkout-index -a -f -u
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

  info "Updating the rewriting state."
  update_state "${CURRENT_SHA}" "${STATE_SKIPPED}"
}

status() {
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi

  info "Reading the original history."
  local line total_lines message
  line="$(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}" | grep -n -F "${CURRENT_SHA}" | cut -d: -f1)"
  total_lines="$(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}" | wc -l | awk '{print $1}')"
  message="$(GIT rev-list -1 --format="%B" "${CURRENT_SHA}" | sed '1d')"

  info "Current state: ${CURRENT_STATE}"
  info "Current step: ${line}/${total_lines}"
  info "Current sha: ${CURRENT_SHA}"
  info "Current commit: ${message}"
}

pre_finalize() {
  info "Checking if it is possible to finalize the work."
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi
  if [[ "${CURRENT_STATE}" != "${STATE_COMMITTED}" && "${CURRENT_STATE}" != "${STATE_SKIPPED}" ]]; then
    die "Cannot finalize. You picked the commit."
  fi

  info "Checking if the end of history was reached."
  local last_sha
  last_sha="$(sed -En '$p' <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  if [[ "${CURRENT_SHA}" != "${last_sha}" ]]; then
    die "End of history not reached."
  fi
}

finalize() {
  pre_finalize

  info "Moving ${ORIGINAL_HEAD} to the rewritten commit."
  GIT update-ref "${ORIGINAL_HEAD}" "${REWRITTEN_HEAD}"

  info "Removing reference to rewritten branch."
  GIT update-ref -d "${REWRITTEN_HEAD}"

  info "Removing configuration file."
  rm "${HISTORY_CONFIG}" 2> /dev/null || true

  info "Removing excluded files from .git/info/exclude."
  sed -E -i '' "/${EXCLUDE_BEGINNING}/,/${EXCLUDE_ENDING}/d" "${REPO_DIR}/.git/info/exclude"
}

abort() {
  info "Removing configuration file."
  rm "${HISTORY_CONFIG}" 2> /dev/null || true

  info "Removing excluded files from .git/info/exclude."
  sed -E -i '' "/${EXCLUDE_BEGINNING}/,/${EXCLUDE_ENDING}/d" "${REPO_DIR}/.git/info/exclude"

  info "Checking out the original HEAD."
  GIT symbolic-ref HEAD "${ORIGINAL_HEAD}"
  GIT read-tree "${ORIGINAL_HEAD}" || error "Could not checkout ${ORIGINAL_HEAD}"
  GIT checkout-index -f -a -u

  info "Removing all other files in the working tree."
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

  info "Removing reference to rewritten branch."
  GIT update-ref -d "${REWRITTEN_HEAD}"
}

rewrite_history() {
  [[ $# -lt 1 ]] && die "Usage: REPO_DIR=<repo_dir> rewrite_history <cmd>."
  [[ ! -d "${REPO_DIR}" ]] && die "'${REPO_DIR}' is not a valid directory."
  ! is_git_repo "${REPO_DIR}" && die "'${REPO_DIR}' is not a git repository."

  local cmd="$1"; shift

  # TODO: flow how to work
  case "${cmd}" in
    init) init "$@" ;;
    pick) pick "$@" ;;
    rollback) rollback "$@" ;;
    skip) skip "$@" ;;
    commit) commit "$@" ;;
    status) status "$@" ;;
    finalize) finalize "$@" ;;
    abort) abort "$@" ;;

    *) die "Command ${cmd} not found." ;;
  esac
}