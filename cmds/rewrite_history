#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" && pwd)"
ROOT_DIR="$(cd -- "${SCRIPT_DIR}/.." && pwd)"
. "${ROOT_DIR}/lib/common"

REPO_DIR="${REPO_DIR:?REPO_DIR is not set}"

REPO_REWRITER_DIR="${REPO_DIR}/.git/repo-rewriter"
HISTORY_CONFIG="${REPO_REWRITER_DIR}/history_config"

EXCLUDE_BEGINNING="###> repo-rewriter ###"
EXCLUDE_ENDING="###< repo-rewriter ###"

# picked ⇄ committed
#    ⇅
# skipped
STATE_PICKED="picked"
STATE_COMMITTED="committed"
STATE_SKIPPED="skipped"

if [[ -s "${HISTORY_CONFIG}" ]]; then
  info "Loading configuration from '${HISTORY_CONFIG}'."
  . "${HISTORY_CONFIG}"
else
  warn "Using default values for configuration."
  ORIGINAL_ROOT="${ORIGINAL_ROOT:-}"
  ORIGINAL_HEAD="${ORIGINAL_HEAD:-refs/heads/main}"
  REWRITTEN_HEAD="${REWRITTEN_HEAD:-refs/heads/rewritten}"
  CURRENT_SHA="${CURRENT_SHA:-}"
  CURRENT_STATE="${CURRENT_STATE:-}"
fi

GIT() {
  git -C "${REPO_DIR}" "$@"
}

print_help() {
  local cmd="${CMD:-}"
  [[ -z "${cmd}" ]] && cmd="$0"

  cat <<EOF
Usage:
  ${cmd} <command> [options]

Description:
  Rewrite a Git repository's history in a controlled, step-by-step workflow.
  The current implementation supports repositories with a linear history only.
  Progress and state are stored under: .git/repo-rewriter

Arguments:
  (Most commands do not take positional arguments; all state is derived
   from the internal config and the target repository.)

Commands:
  init              Initialize the rewriting session from the original root.
  pick              Apply the next original commit into the working tree (3-way merge).
  commit            Create a rewritten commit from the current index/WT (only in 'picked' state).
  skip              Skip the current original commit and clean the working tree.
  rollback          Move one step back in the process (original and/or rewritten history).
  status            Show current state, progress (N/Total), SHA, and original message.
  finalize          Switch the original head ref to the rewritten history and clean up.
  abort             Restore the repository to the original state and remove all rewriter data.

Common Options:
  --help            Show this help message and exit.

Per-command Options:
  init, pick, commit, skip, rollback, finalize:
    --dry-run       Validate preconditions only; do not change anything.

  rollback:
    --not-rewritten Do not move the rewritten history back (original progress only).

Environment:
  REPO_DIR          (required) Absolute or relative path to the target repository.
  COMMIT_MESSAGE    (optional, commit) Override the original commit message when
                    creating the rewritten commit; author/committer/timestamps
                    are preserved from the original.

Workflow:
  States: picked ⇄ committed
             ⇅
          skipped

  Typical flow:
    init → commit → pick → skip → pick → commit → ... → finalize
             ↑              ↑              ↑
          rollback       rollback       rollback
    abort can be used at any time to restore the original state.

Notes:
  - 'init' verifies: linear history, clean working tree, and reachable root.
  - 'pick' materializes the next original commit via a 3-way merge into WT/index.
  - 'commit' records the current index as the next rewritten commit, carrying over
    author/committer identities and dates from the matched original commit.
  - 'skip' advances the original progression and cleans WT/index accordingly.
  - 'rollback' steps back one original commit; optionally also moves the rewritten ref.
  - 'finalize' moves the original head to the rewritten ref, reattaches HEAD, and cleans up.

Examples:
  # Start a process (dry-run first), it also picks the first commit:
  REPO_DIR="\$(pwd)" ${cmd} init --dry-run
  REPO_DIR="\$(pwd)" ${cmd} init

  # Commit the picked changes (preserving original metadata):
  REPO_DIR="\$(pwd)" ${cmd} commit
  REPO_DIR="\$(pwd)" COMMIT_MESSAGE="Tweak message if needed" ${cmd} commit

  # Pick the next original commit and inspect status:
  REPO_DIR="\$(pwd)" ${cmd} pick
  REPO_DIR="\$(pwd)" ${cmd} status

  # Skip the current original commit:
  REPO_DIR="\$(pwd)" ${cmd} skip

  # Roll back one step (do not move rewritten history):
  REPO_DIR="\$(pwd)" ${cmd} rollback --not-rewritten

  # Finalize after all steps are done:
  REPO_DIR="\$(pwd)" ${cmd} finalize

  # Abort at any time to restore the original state:
  REPO_DIR="\$(pwd)" ${cmd} abort

EOF
}

list_of_ignored() {
  sanitize() {
    grep -vE -e '^#' -e '^[[:space:]]*$' | sed -E -e 's|^\.?/||' -e 's|/+$||' -e 's|^|/|'
  }

  local excluded=
  if [[ -f "${REPO_DIR}/.gitignore" ]]; then
    excluded="$(sanitize < "${REPO_DIR}/.gitignore" | \
      sed -E -e "s|^|${REPO_DIR}|" | \
      xargs -I'{}' sh -c "test -d '{}' && echo '{}' || true" | \
      sed -E -e "s|(.+)|-not -path '\1/*'|" | \
      paste -s -d' ' -
    )"
  fi

  local dir
  while read -r gitignore; do
    dir=$(dirname "${gitignore}")
    sanitize < "${gitignore}" | xargs -I'{}' sh -c "echo ${dir#"${REPO_DIR}"}{}"
  done < <(eval "find '${REPO_DIR}' -type f -name '.gitignore' ! -empty ${excluded}")
}

update_state() {
  local sha="$1" state="$2"
  sed -E -i '' \
    -e "/^CURRENT_SHA/s/^.+\$/CURRENT_SHA=${sha}/" \
    -e "/^CURRENT_STATE/s/^.+\$/CURRENT_STATE=${state}/" \
    "${HISTORY_CONFIG}"

  CURRENT_SHA="${sha}"
  CURRENT_STATE="${state}"
}

pre_init() {
  info "Checking if it is possible to initiate."
  if [[ -n "${CURRENT_STATE}" ]]; then
    die "Rewritten process was already initiated."
  fi

  info "Checking if ${ORIGINAL_HEAD} exists."
  if ! GIT show-ref --heads --quiet "${ORIGINAL_HEAD}"; then
    die "Original HEAD ${ORIGINAL_HEAD} not exist."
  fi

  info "Checking if history is not linear."
  if [[ $(GIT rev-list --min-parents=2 "${ORIGINAL_HEAD}" | wc -l) -ne 0 ]]; then
    die "History is not linear."
  fi

  info "Setting root repository if another is not specified."
  if [[ -z "${ORIGINAL_ROOT}" ]]; then
    ORIGINAL_ROOT="$(GIT rev-list --max-parents=0 "${ORIGINAL_HEAD}")"
  fi

  info "Checking if they are part of the same history."
  if ! GIT merge-base --is-ancestor "${ORIGINAL_ROOT}" "${ORIGINAL_HEAD}"; then
    die "${ORIGINAL_ROOT} is not an ancestor of ${ORIGINAL_HEAD}."
  fi

  info "Checking if some uncommitted changes exist."
  if ! GIT diff-index --quiet HEAD; then
    die "The index or working tree is dirty."
  fi
}

init() {
  pre_init
  has_flag "--dry-run" "$@" && exit 0

  # Utility preparation
  info "Populating .git/info/exclude with originally ignored files."
  (
    echo "${EXCLUDE_BEGINNING}"
    list_of_ignored
    echo "${EXCLUDE_ENDING}"
  ) >> "${REPO_DIR}/.git/info/exclude"

  info "Creating a folder for repo-rewriter tool if it does not exist."
  mkdir -p "${REPO_REWRITER_DIR}"

  info "Setting the configuration of the rewriting process."
  (
    echo "ORIGINAL_ROOT=${ORIGINAL_ROOT}"
    echo "ORIGINAL_HEAD=${ORIGINAL_HEAD}"
    echo "REWRITTEN_HEAD=${REWRITTEN_HEAD}"
    echo "CURRENT_SHA=${ORIGINAL_ROOT}"
    echo "CURRENT_STATE=${STATE_PICKED}"
  ) > "${HISTORY_CONFIG}"

  # Repository manipulation
  info "Moving HEAD to no reference."
  GIT symbolic-ref HEAD "${REWRITTEN_HEAD}"

  info "Populating the working tree with changes from the root commit."
  GIT read-tree "${ORIGINAL_ROOT}"
  GIT checkout-index -a -f

  info "Removing all other files and empty folders in the working tree."
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"
  find "${REPO_DIR}" -type d -empty -delete

  info "Purifying the index."
  GIT read-tree --empty

  info "Initialization was successful. Root commit was checked out."
}

pre_pick() {
  info "Checking if it is possible to pick the next commit."
  if [[ "${CURRENT_STATE}" != "${STATE_COMMITTED}" && "${CURRENT_STATE}" != "${STATE_SKIPPED}" ]]; then
    die "Cannot pick the next commit. You have already picked the commit."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Checking if there are staged files present."
  if ! GIT diff-index --cached --quiet HEAD; then
    die "There are staged files."
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    die "There are unstaged files."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    die "There are untracked files."
  fi
}

pick() {
  pre_pick
  has_flag "--dry-run" "$@" && exit 0

  info "Checking if the end of history was reached."
  local last
  last="$(sed -En '$p' <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  if [[ "${CURRENT_SHA}" == "$last" ]]; then
    die "End of history reached."
  fi

  info "Getting the next commit."
  local next_sha
  next_sha="$(sed -En "/^${CURRENT_SHA}\$/{n;p;q;}" <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  info "The ${next_sha} commit has taken."

  info "Populating temporary index with changes from the picked commit (with 3-way merge)."
  local idx ours
  idx="$(mktemp -d)/index"
  ours="$(GIT write-tree)"
  GIT_INDEX_FILE="${idx}" GIT read-tree -m --aggressive "${CURRENT_SHA}" "${ours}" "${next_sha}"
  GIT_INDEX_FILE="${idx}" GIT checkout-index -a -f
  GIT_INDEX_FILE="${idx}" REPO_DIR="${REPO_DIR}" GIT merge-index -o -q "${ROOT_DIR}/cmds/merge" -a || true

  info "Placing conflict files in the index."
  if GIT_INDEX_FILE="${idx}" GIT ls-files -u | grep -q .; then
    GIT_INDEX_FILE="${idx}" GIT ls-files -u --format='%(path)' -z | GIT update-index -z --force-remove --stdin
    GIT_INDEX_FILE="${idx}" GIT ls-files -u -z | GIT update-index -z --index-info
  fi

  info "Sanitizing working tree from non conflict files."
  while IFS= read -r -d '' p; do
    if ! GIT_INDEX_FILE="$idx" GIT ls-files --error-unmatch -- "${p}" 2> /dev/null; then
      rm -rf -- "${REPO_DIR}/${p}"
    fi
  done < <(GIT diff-tree -z -r --diff-filter=D --name-only "${next_sha}~1" "${next_sha}")


  info "Updating the rewriting state."
  update_state "${next_sha}" "${STATE_PICKED}"

  status
}

pre_commit() {
  info "Checking if it is possible to make a commit."
  if [[ "${CURRENT_STATE}" != "${STATE_PICKED}" ]]; then
    die "Cannot commit the changes. You have to pick the commit first."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Picking a base to diff the index against."
  local against=HEAD
  if ! GIT rev-parse --verify --quiet HEAD >/dev/null; then
    against=$(GIT hash-object -t tree /dev/null)
  fi

  info "Checking if there are staged files present."
  if GIT diff-index --cached --quiet "${against}" --; then
    if GIT diff-tree --quiet "${CURRENT_SHA}~1" "${CURRENT_SHA}"; then
      warn "Committing empty commit"
    else
      die "Nothing to commit."
    fi
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    die "There are unstaged files."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    die "There are some untracked files that will be not committed."
  fi
}

commit() {
  pre_commit
  has_flag "--dry-run" "$@" && exit 0

  info "Creating a tree object from the current index."
  local tree_sha
  tree_sha="$(GIT write-tree)"

  info "Extracting all metadata from the original commit."
  local format author_name author_email author_date committer_name committer_email committer_date message
  format="%an%x00%ae%x00%aD%x00%cn%x00%ce%x00%cD%x00%B%x00"
  exec 3< <(GIT rev-list -1 --format="${format}" "${CURRENT_SHA}" | sed '1d')
  IFS= read -r -d '' author_name <&3
  IFS= read -r -d '' author_email <&3
  IFS= read -r -d '' author_date <&3
  IFS= read -r -d '' committer_name <&3
  IFS= read -r -d '' committer_email <&3
  IFS= read -r -d '' committer_date <&3
  IFS= read -r -d '' message <&3
  exec 3<&-

  COMMIT_MESSAGE="${COMMIT_MESSAGE:-"${message}"}"

  info "Extracting a parent commit of rewritten history."
  local commit_cmd
  if GIT rev-parse --verify --quiet HEAD >/dev/null; then
    commit_cmd="GIT commit-tree -p '$(GIT rev-parse HEAD)' '${tree_sha}'"
  else
    commit_cmd="GIT commit-tree '${tree_sha}'"
  fi

  info "Creating a commit with all available metadata."
  local commit_sha
  commit_sha="$(printf '%s' "${COMMIT_MESSAGE}" | \
    GIT_AUTHOR_NAME="${author_name}" \
    GIT_AUTHOR_EMAIL="${author_email}" \
    GIT_AUTHOR_DATE="${author_date}" \
    GIT_COMMITTER_NAME="${committer_name}" \
    GIT_COMMITTER_EMAIL="${committer_email}" \
    GIT_COMMITTER_DATE="${committer_date}" \
    eval "${commit_cmd}"
  )"

  info "Moving the ref to the created commit."
  GIT update-ref "${REWRITTEN_HEAD}" "${commit_sha}"

  info "Updating the rewriting state."
  update_state "${CURRENT_SHA}" "${STATE_COMMITTED}"

  status
}

pre_rollback() {
  info "Checking if it is possible to rollback to the previous commit."
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi

  if [[ "${CURRENT_SHA}" == "${ORIGINAL_ROOT}" ]]; then
    die "Root commit of original history reached. "
  fi
}

rollback() {
  pre_rollback
  has_flag "--dry-run" "$@" && exit 0

  if has_flag "--not-rewritten" "$@"; then
    info "Skipping rollback of rewritten history."
  elif ! GIT rev-list HEAD~1 -1 2> /dev/null; then
    warn "Skipping rollback of rewritten history due to reaching the root."
  elif [[ "${CURRENT_STATE}" == "${STATE_PICKED}" ]]; then
    info "Cleaning working tree."

    info "Sanitizing the index and populating the working tree with current commit."
    GIT read-tree HEAD
    GIT checkout-index -a -f -u
    GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"
  else
    info "Rolling back to the previous commit."

    info "Getting the previous commit."
    local previous_sha
    previous_sha="$(GIT rev-list HEAD~1 -1)"

    info "Sanitizing the index and populating the working tree with previous commit."
    GIT read-tree "${previous_sha}"
    GIT checkout-index -a -f -u
    GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

    info "Moving the reference to the previous commit."
    GIT update-ref "${REWRITTEN_HEAD}" "${previous_sha}"
  fi

  info "Getting the original previous sha."
  local original_previous_sha
  original_previous_sha="$(sed -En "/^${CURRENT_SHA}\$/{g;p;q;}; h" <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"

  info "Updating the rewriting state."
  update_state "${original_previous_sha}" "${STATE_COMMITTED}"

  status
}

pre_skip() {
  info "Checking if it is possible to skip current commit."
  if [[ "${CURRENT_STATE}" != "${STATE_PICKED}" ]]; then
    die "Cannot skip current commit. You have to pick the commit first."
  fi

  info "Checking if the current HEAD refers to ${REWRITTEN_HEAD}."
  local symbolic_ref
  symbolic_ref="$(GIT symbolic-ref HEAD)"
  if [[ "${symbolic_ref}" != "${REWRITTEN_HEAD}" ]]; then
    die "The current HEAD is not ${symbolic_ref}."
  fi

  info "Picking a base to diff the index against."
  local against=HEAD
  if ! GIT rev-parse --verify --quiet HEAD >/dev/null; then
    against=$(GIT hash-object -t tree /dev/null)
  fi

  info "Checking if there are staged files present."
  if GIT diff-index --cached --quiet "${against}" --; then
    warn "There are some staged files that will be erased."
  fi

  info "Checking if there are unstaged files present."
  if ! GIT diff-files --quiet; then
    warn "There are unstaged files that will be erased."
  fi

  info "Checking if there are untracked files present."
  if GIT ls-files --others --exclude-standard | head -n1 | grep -q .; then
    warn "There are some untracked files that will be erased."
  fi
}

skip() {
  pre_skip
  has_flag "--dry-run" "$@" && exit 0

  info "Reading the current commit."
  local current_sha
  read -r current_sha < <(GIT rev-list HEAD -1)

  info "Sanitizing the index and populating the working tree with current HEAD."
  GIT read-tree "${current_sha}"
  GIT checkout-index -a -f -u
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

  info "Updating the rewriting state."
  update_state "${CURRENT_SHA}" "${STATE_SKIPPED}"
}

status() {
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi

  info "Reading the original history."
  local line total_lines message
  line="$(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}" | grep -n -F "${CURRENT_SHA}" | cut -d: -f1)"
  total_lines="$(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}" | wc -l | awk '{print $1}')"
  message="$(GIT rev-list -1 --format="%B" "${CURRENT_SHA}" | sed '1d')"

  info "Current state: ${CURRENT_STATE}"
  info "Current step: ${line}/${total_lines}"
  info "Current sha: ${CURRENT_SHA}"
  info "Current commit: ${message}"
}

pre_finalize() {
  info "Checking if it is possible to finalize the work."
  if [[ -z "${CURRENT_STATE}" ]]; then
    die "Rewriting processes not started."
  fi
  if [[ "${CURRENT_STATE}" != "${STATE_COMMITTED}" && "${CURRENT_STATE}" != "${STATE_SKIPPED}" ]]; then
    die "Cannot finalize. You picked the commit."
  fi

  info "Checking if the end of history was reached."
  local last_sha
  last_sha="$(sed -En '$p' <(GIT rev-list --reverse "${ORIGINAL_HEAD}" "${ORIGINAL_ROOT}"))"
  if [[ "${CURRENT_SHA}" != "${last_sha}" ]]; then
    die "End of history not reached."
  fi
}

finalize() {
  pre_finalize
  has_flag "--dry-run" "$@" && exit 0

  info "Moving ${ORIGINAL_HEAD} to the rewritten commit."
  GIT update-ref "${ORIGINAL_HEAD}" "${REWRITTEN_HEAD}"

  info "Repointing HEAD to ${ORIGINAL_HEAD} branch."
  GIT symbolic-ref HEAD "${ORIGINAL_HEAD}"

  info "Removing reference to rewritten branch."
  GIT update-ref -d "${REWRITTEN_HEAD}"

  info "Removing configuration file."
  rm "${HISTORY_CONFIG}" 2> /dev/null || true

  info "Removing excluded files from .git/info/exclude."
  sed -E -i '' "/${EXCLUDE_BEGINNING}/,/${EXCLUDE_ENDING}/d" "${REPO_DIR}/.git/info/exclude"
}

abort() {
  info "Removing configuration file."
  rm "${HISTORY_CONFIG}" 2> /dev/null || true

  info "Removing excluded files from .git/info/exclude."
  sed -E -i '' "/${EXCLUDE_BEGINNING}/,/${EXCLUDE_ENDING}/d" "${REPO_DIR}/.git/info/exclude"

  info "Checking out the original HEAD."
  GIT symbolic-ref HEAD "${ORIGINAL_HEAD}"
  GIT read-tree "${ORIGINAL_HEAD}" || error "Could not checkout ${ORIGINAL_HEAD}"
  GIT checkout-index -f -a -u

  info "Removing all other files in the working tree."
  GIT ls-files --others --exclude-standard -z | xargs -0 -r -I{} rm -rf -- "${REPO_DIR}/{}"

  info "Removing reference to rewritten branch."
  GIT update-ref -d "${REWRITTEN_HEAD}"
}

main() {
  has_flag "--help" "$@" && print_help && exit 0

  [[ $# -lt 1 ]] && die "Usage: REPO_DIR=<repo_dir> rewrite_history <cmd>."
  [[ ! -d "${REPO_DIR}" ]] && die "'${REPO_DIR}' is not a valid directory."
  ! is_git_repo "${REPO_DIR}" && die "'${REPO_DIR}' is not a git repository."

  local cmd="$1"; shift

  case "${cmd}" in
    init) init "$@" ;;
    pick) pick "$@" ;;
    rollback) rollback "$@" ;;
    skip) skip "$@" ;;
    commit) commit "$@" ;;
    status) status "$@" ;;
    finalize) finalize "$@" ;;
    abort) abort "$@" ;;

    *) die "Command ${cmd} not found." ;;
  esac
}

main "$@"
