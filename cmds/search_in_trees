#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR=$(CDPATH="" cd -- "$(dirname -- "$0")" && pwd)
ROOT_DIR=$(CDPATH="" cd -- "${SCRIPT_DIR}/.." && pwd)
. "${ROOT_DIR}/lib/common"

GIT() {
  git -C "${REPO_DIR}" "$@"
}

# Produces in format commit:filepath:count (sorted by commit, filepath)
grep_commits() {
  local text="$1"; shift
  local grep_flags="$@"

  GIT grep --no-color -l ${grep_flags} -- "${text}" $(GIT rev-list --all)
}

# Produces in format commit<tab>filepath<tab>blob_sha
add_blob_sha() {
  sed -E 's/^([^:]+):(.+)$/\1:\2\t\1\t\2/' | GIT cat-file --batch-check=$'%(rest)\t%(objectname)'
}

# Produces in format total<tab>oldest_commit<tab>filepath<tab>blob_sha
group_by_filepath() {
  cat -n \
  | sed 's/^[[:space:]]*//' \
  | sort -t $'\t' -k3,3 -k1,1nr \
  | cut -d $'\t' -f2- \
  | uniq -f1 -c \
  | sed -E 's/^[[:space:]]*([[:digit:]]*)[[:space:]]*/\1\t/'
}

# Produces ranges of hunk lines (column format)
hunk_lines() {
  local prev_commit="$1"
  local commit="$2"
  local filepath="$3"

  GIT diff-tree -U0 --no-color "${prev_commit}" "${commit}" -- "${filepath}" \
  | grep '^@@' | sed -E 's/^@@ -[0-9]+(,[0-9]+)? \+([0-9]+)(,([0-9]+))? @@.*$/\2 \4/' \
  | while read -r start len; do
      : "${len:=1}"
      [[ "${len}" -eq 0 ]] && continue
      end=$((start + len - 1))
      seq "${start}" "${end}"
    done
}

# Produces a matches line (column format)
match_lines() {
  local blob_sha="$1"
  local text="$2"
  shift 2
  local grep_flags="$@"

  GIT cat-file -p "${blob_sha}" | grep -n ${grep_flags} "${text}" | cut -d: -f1
}

# Produces set of intersected lines (column format)
intersect() {
  local matches_lines="$1"
  local hunks_lines="$2"

  grep -Fxf <(echo -n "${matches_lines}") <(echo -n "${hunks_lines}") || true
}

print_lines() {
  local blob_sha="$1"
  local text="$2"
  local lines="$3"
  local context="$4"
  shift 4;
  local grep_flags="$@"

  local offset=3
  local i=0

  echo "--- ${blob_sha}"
  echo -n "${lines}" | \
  while read -r line_number || [[ -n "${line_number}" ]]; do
    start=$((line_number - context))
    [[ "${start}" -le 0 ]] && start=1
    end=$((line_number + context))

    [[ $((i++)) -ge 1 ]] && echo '---'

    GIT cat-file -p "${blob_sha}" \
    | nl -ba -w"${offset}" -s' ' \
    | sed -n "${start},${end}p" \
    | grep --color=always ${grep_flags} "${text}"
  done
}

search_in_trees() {
  local text="$1"; shift
  local ignore_case=
  local context_num=2
  local context="--context=${context_num}"

  has_flag "-i" "$@" && ignore_case="--ignore-case"
  has_flag "-C" "$@" && context_num="$(flag_value "-C" "$@")" && context="--context=${context_num}"

  local prev_commit
  local prev_filepath=
  local empty_commit="$(GIT hash-object -t tree /dev/null)"
  local l1 l2 lines

  grep_commits "${text}" "${ignore_case}" \
  | add_blob_sha \
  | group_by_filepath \
  | while IFS=$'\t' read -r total commit filepath blob_sha; do
      if [[ "${prev_filepath}" != "${filepath}" ]]; then
         prev_commit="${empty_commit}"
         echo -e "--- \e[30;43m${filepath}\e[0m"
      fi

      l1="$(hunk_lines "${prev_commit}" "${commit}" "${filepath}")"
      l2="$(match_lines "${blob_sha}" "${text}" "${ignore_case}")"
      lines="$(intersect "${l1}" "${l2}")"

      [[ -n "${lines}" ]] && print_lines "${blob_sha}" "${text}" "${lines}" "${context_num}" "${ignore_case}" "${context}"

      prev_commit="${commit}"
      prev_filepath="${filepath}"
    done
}