#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR=$(CDPATH="" cd -- "$(dirname -- "$0")" && pwd)
ROOT_DIR=$(CDPATH="" cd -- "${SCRIPT_DIR}/.." && pwd)
. "${ROOT_DIR}/lib/common"

OFFSET="---"
OFFSET_LEN=3

GIT() {
  git -C "${REPO_DIR}" "$@"
}

# Produces in format commit:filepath:count (sorted by commit, filepath)
grep_commits() {
  local search="$1"
  local pathspec="$2"
  shift 2
  local grep_flags="$@"

  GIT --no-pager grep --no-color -I -l ${grep_flags} -- "${search}" $(GIT rev-list --all) -- ${pathspec} || true
}

# Produces in format commit<tab>filepath<tab>blob_sha
add_blob_sha() {
  sed -E 's/^([^:]+):(.+)$/\1:\2\t\1\t\2/' \
  | GIT cat-file --batch-check=$'%(rest)\t%(objectname)'
}

# Produces in format commit<tab>filepath<tab>blob_sha
group_by_filepath() {
  cat -n \
  | sed 's/^[[:space:]]*//' \
  | sort -t $'\t' -k3,3 -k1,1nr \
  | cut -d $'\t' -f2- \
  | uniq -f1
}

# Produces ranges of hunk lines (column format)
hunk_lines() {
  local prev_commit="$1"
  local commit="$2"
  local filepath="$3"

  GIT diff-tree -U0 --no-color "${prev_commit}" "${commit}" -- "${filepath}" \
  | grep '^@@' \
  | sed -E 's/^@@ -[0-9]+(,[0-9]+)? \+([0-9]+)(,([0-9]+))? @@.*$/\2 \4/' \
  | while read -r start len; do
      : "${len:=1}"
      [[ "${len}" -eq 0 ]] && continue
      end=$((start + len - 1))
      seq "${start}" "${end}"
    done
}

# Produces a matches line (column format)
match_lines() {
  local blob_sha="$1"
  local search="$2"
  shift 2
  local grep_flags="$@"

  GIT cat-file -p "${blob_sha}" | grep -n ${grep_flags} "${search}" | cut -d: -f1
}

# Produces set of intersected lines (column format)
intersect() {
  local matches_lines="$1"
  local hunks_lines="$2"

  grep -Fxf <(echo -n "${matches_lines}") <(echo -n "${hunks_lines}") || true
}

print_lines() {
  local blob_sha="$1"
  local search="$2"
  local lines="$3"
  local context="$4"
  shift 4;
  local grep_flags="$@"

  local i=0

  echo "${OFFSET} ${blob_sha}"
  echo -n "${lines}" | \
  while read -r line_number || [[ -n "${line_number}" ]]; do
    start=$((line_number - context))
    [[ "${start}" -le 0 ]] && start=1
    end=$((line_number + context))

    [[ $((i++)) -ge 1 ]] && echo "${OFFSET}"

    GIT cat-file -p "${blob_sha}" \
    | nl -ba -w"${OFFSET_LEN}" -s' ' \
    | sed -n "${start},${end}p" \
    | grep --color=always ${grep_flags} "${search}"
  done
}

search_in_trees() {
  local search="$1"; shift
  local ignore_case=
  local word_regexp=
  local context_num=2
  local context="--context=${context_num}"
  local pathspec=

  has_flag "-i" "$@" && ignore_case="--ignore-case"
  has_flag "-w" "$@" && word_regexp="--word-regexp"
  has_flag "-C" "$@" && context_num="$(flag_value "-C" "$@")" && context="--context=${context_num}"
  has_flag "-p" "$@" && pathspec="$(flag_value "-p" "$@" | paste -sd' ' -)"

  local prev_commit
  local prev_filepath=
  local empty_commit="$(GIT hash-object -t tree /dev/null)"
  local l1 l2 lines
  local found= total_files=0 total_found=0

  while IFS=$'\t' read -r commit filepath blob_sha; do
    if [[ "${prev_filepath}" != "${filepath}" ]]; then
       prev_commit="${empty_commit}"
       echo -e "${OFFSET} \e[30;43m${filepath}\e[0m"
       : $((++total_files))
    fi

    l1="$(hunk_lines "${prev_commit}" "${commit}" "${filepath}")"
    l2="$(match_lines "${blob_sha}" "${search}" "${ignore_case}" "${word_regexp}")"
    lines="$(intersect "${l1}" "${l2}")"

    if [[ -n "${lines}" ]]; then
      print_lines "${blob_sha}" "${search}" "${lines}" "${context_num}" "${ignore_case}" "${word_regexp}" "${context}"
      found="$(echo "${lines}" | wc -l | awk '{print $1}')"
      total_found=$((total_found + found))
    fi

    prev_commit="${commit}"
    prev_filepath="${filepath}"
    done < <(grep_commits "${search}" "${pathspec}" "${ignore_case}" "${word_regexp}" \
      | add_blob_sha \
      | group_by_filepath)

    # Calculate stats
    echo "Total files: ${total_files}"
    echo "Total found: ${total_found}"
}
