#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" && pwd)"
ROOT_DIR="$(cd -- "${SCRIPT_DIR}/.." && pwd)"
. "${ROOT_DIR}/lib/common"

REPO_DIR="${REPO_DIR:?REPO_DIR is not set}"

OFFSET="---"
OFFSET_LEN="${#OFFSET}"

print_help() {
  local cmd="${CMD:-}"
  [[ -z "${cmd}" ]] && cmd="$0"

  cat <<EOF
Usage:
  ${cmd} <search> [-i] [-w] [-C=<num>] [-p=<pathspec>...]

Description:
  Search all blob contents across the full history. Results are reported as
  "filepath+blob" pairs deduplicated to the oldest commit where they appear.
  To reduce noise, a match is shown only if the diff around that blob revision
  actually contains the searched pattern.

  At the end, prints statistics: total files scanned and total matches found.

Arguments:
  <search>          Regexp pattern to find.

Options:
  -i                Ignore case.
  -w                Match the search term as a whole word (word-regex).
  -C=<num>          Show <num> context lines before and after each match (default: 2).
  -p=<pathspec>     Restrict search to paths matching <pathspec>. May be repeated.
  --help            Show this help message and exit.

Environment:
  REPO_DIR          (required) Path to the target repository.

Examples:
  REPO_DIR="\$(pwd)" ${cmd} 'SECRET_TOKEN'
  REPO_DIR="\$(pwd)" ${cmd} 'secret_token' -i -w
  REPO_DIR="\$(pwd)" ${cmd} 'TODO' -C=5 -p='*.go' -p='docs/**'
  REPO_DIR="\$(pwd)" ${cmd} '^[a-z]+\$'
EOF
}

# Produces in format commit:filepath:count (sorted by commit, filepath)
grep_commits() {
  local search="$1"
  local pathspec="$2"
  shift 2
  local grep_flags="$@"

  # --perl-regexp must not be used, but for some reason --extended-regexp doesn't work properly
  # Use --extended-regexp features and DO NOT use --perl-regexp features
  GIT --no-pager grep --no-color -I --name-only --perl-regexp ${grep_flags} -- "${search}" $(GIT rev-list --all) -- ${pathspec} || true
}

# Produces in format commit<tab>filepath<tab>blob_sha
add_blob_sha() {
  sed -E 's/^([^:]+):(.+)$/\1:\2\t\1\t\2/' \
  | GIT cat-file --batch-check=$'%(rest)\t%(objectname)'
}

# Produces in format oldest_commit<tab>filepath<tab>blob_sha
group_by_filepath() {
  nl -ba -s $'\t' -w1 \
  | sort -t $'\t' -k3,3 -k1,1nr \
  | cut -d $'\t' -f2- \
  | uniq -f1
}

# Produces in format count<tab>filepath
count_by_filepath() {
  cut -d $'\t' -f2- \
  | sort -t $'\t' -k1,1 \
  | uniq \
  | cut -f1 \
  | uniq -c \
  | sed -E 's/^[[:space:]]*([0-9]+)[[:space:]]*/\1\t/'
}

# Produces in format
# count1 (new line ˣ count1)
# count2 (new line ˣ count2)
expand_with_new_lines() {
  while read -r total _; do
    printf '%s' "${total}"
    seq 1 "${total}" | tr -d '[:digit:]'
  done
}

# Produces ranges of hunk lines (column format)
hunk_lines() {
  local prev_commit="$1"
  local commit="$2"
  local filepath="$3"

  GIT diff-tree -U0 --no-color "${prev_commit}" "${commit}" -- "${filepath}" \
  | grep '^@@' \
  | sed -E 's/^@@ -[0-9]+(,[0-9]+)? \+([0-9]+)(,([0-9]+))? @@.*$/\2 \4/' \
  | while read -r start len; do
      : "${len:=1}"
      [[ "${len}" -eq 0 ]] && continue
      end=$((start + len - 1))
      seq "${start}" "${end}"
    done
}

# Produces a matches line (column format)
match_lines() {
  local blob_sha="$1"
  local search="$2"
  shift 2
  local grep_flags="$@"

  GIT cat-file -p "${blob_sha}" | grep -E -n ${grep_flags} "${search}" | cut -d: -f1
}

# Produces set of intersected lines (column format)
intersect() {
  local matches_lines="$1"
  local hunks_lines="$2"

  grep -Fxf <(echo -n "${matches_lines}") <(echo -n "${hunks_lines}") || true
}

print_lines() {
  local blob_sha="$1"
  local search="$2"
  local lines="$3"
  local context_num="$4"
  shift 4;
  local grep_flags="$@"

  local i=0

  echo "${OFFSET} ${blob_sha}"
  echo -n "${lines}" | \
  while read -r line_number || [[ -n "${line_number}" ]]; do
    start=$((line_number - context_num))
    [[ "${start}" -le 0 ]] && start=1
    end=$((line_number + context_num))

    [[ $((i++)) -ge 1 ]] && echo "${OFFSET}"

    local content
    content="$(GIT cat-file -p "${blob_sha}")"
    (
      [[ "${line_number}" -gt "${start}" ]] && sed -n "${start},$((line_number-1))p" <<< "${content}"
      sed -n "${line_number}p" <<< "${content}" | grep -E --color=always ${grep_flags} "${search}"
      [[ "${line_number}" -lt "${end}" ]] && sed -n "$((line_number+1)),${end}p" <<< "${content}"
      return 0
    ) | nl -ba -w"${OFFSET_LEN}" -s' ' -v"${start}"
  done
}

main() {
  has_flag "--help" "$@" && print_help && exit 0

  local search="$1"; shift
  local ignore_case=
  local word_regexp=
  local context_num=2
  local pathspec=

  has_flag "-i" "$@" && ignore_case="--ignore-case"
  has_flag "-w" "$@" && word_regexp="--word-regexp"
  has_flag "-C" "$@" && context_num="$(flag_value "-C" "$@")"
  has_flag "-p" "$@" && pathspec="$(flag_value "-p" "$@" | paste -sd' ' -)"

  local prev_commit
  local prev_filepath=
  local empty_commit="$(GIT hash-object -t tree /dev/null)"
  local l1 l2 lines
  local found= total_files=0 total_found=0

  local commit_filepath_blob=
  commit_filepath_blob="$(grep_commits "${search}" "${pathspec}" "${ignore_case}" "${word_regexp}" | add_blob_sha)"

  while IFS=$'\t' read -r commit filepath blob_sha total; do
    if [[ "${prev_filepath}" != "${filepath}" ]]; then
       prev_commit="${empty_commit}"
       echo -e "${OFFSET} \e[30;43m${filepath}\e[0m (actual blobs: ${total})"
       : $((++total_files))
    fi

    l1="$(hunk_lines "${prev_commit}" "${commit}" "${filepath}")"
    l2="$(match_lines "${blob_sha}" "${search}" "${ignore_case}" "${word_regexp}")"
    lines="$(intersect "${l1}" "${l2}")"

    if [[ -n "${lines}" ]]; then
      print_lines "${blob_sha}" "${search}" "${lines}" "${context_num}" "${ignore_case}" "${word_regexp}"
      found="$(echo "${lines}" | wc -l | awk '{print $1}')"
      total_found=$((total_found + found))
    fi

    prev_commit="${commit}"
    prev_filepath="${filepath}"
    done < <(paste -d $'\t' \
      <(group_by_filepath <<< "${commit_filepath_blob}") \
      <(count_by_filepath <<< "${commit_filepath_blob}" | expand_with_new_lines) \
    )

    # Calculate stats
    echo "Total files: ${total_files}"
    echo "Total found: ${total_found}"
}

main "$@"
