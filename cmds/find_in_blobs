#!/usr/bin/env bash

set -Eeuo pipefail

SCRIPT_DIR="$(cd -- "$(dirname -- "$0")" && pwd)"
ROOT_DIR="$(cd -- "${SCRIPT_DIR}/.." && pwd)"
. "${ROOT_DIR}/lib/common"

REPO_DIR="${REPO_DIR:?REPO_DIR is not set}"

OFFSET="---"
OFFSET_LEN=3

print_help() {
  local cmd="${CMD:-}"
  [[ -z "${cmd}" ]] && cmd="$0"

  cat <<EOF
Usage:
  ${cmd} <search> [-i] [-w] [-C=<num>] [-p=<pathspec>...]

Description:
  Search all blob contents across the full history. Results are reported as
  "filepath+blob" pairs deduplicated to the oldest commit where they appear.
  To reduce noise, a match is shown only if the diff around that blob revision
  actually contains the searched pattern.

  At the end, prints statistics: total files scanned and total matches found.

Arguments:
  <search>          Literal pattern to find.

Options:
  -i                Ignore case.
  -w                Match the search term as a whole word (word-regex).
  -C=<num>          Show <num> context lines before and after each match (default: 2).
  -p=<pathspec>     Restrict search to paths matching <pathspec>. May be repeated.
  --help            Show this help message and exit.

Environment:
  REPO_DIR          (required) Path to the target repository.

Examples:
  REPO_DIR="\$(pwd)" ${cmd} 'SECRET_TOKEN'
  REPO_DIR="\$(pwd)" ${cmd} 'secret_token' -i -w
  REPO_DIR="\$(pwd)" ${cmd} 'TODO' -C=5 -p='*.go' -p='docs/**'
EOF
}

# Produces in format commit:filepath:count (sorted by commit, filepath)
grep_commits() {
  local search="$1"
  local pathspec="$2"
  shift 2
  local grep_flags="$@"

  # shellcheck disable=SC2046
  GIT --no-pager grep --no-color -I -l ${grep_flags} -- "${search}" $(GIT rev-list --all) -- ${pathspec} || true
}

# Produces in format commit<tab>filepath<tab>blob_sha
add_blob_sha() {
  sed -E 's/^([^:]+):(.+)$/\1:\2\t\1\t\2/' \
  | GIT cat-file --batch-check=$'%(rest)\t%(objectname)'
}

# Produces in format commit<tab>filepath<tab>blob_sha
group_by_filepath() {
  cat -n \
  | sed 's/^[[:space:]]*//' \
  | sort -t $'\t' -k3,3 -k1,1nr \
  | cut -d $'\t' -f2- \
  | uniq -f1
}

# Produces ranges of hunk lines (column format)
hunk_lines() {
  local prev_commit="$1"
  local commit="$2"
  local filepath="$3"

  GIT diff-tree -U0 --no-color "${prev_commit}" "${commit}" -- "${filepath}" \
  | grep '^@@' \
  | sed -E 's/^@@ -[0-9]+(,[0-9]+)? \+([0-9]+)(,([0-9]+))? @@.*$/\2 \4/' \
  | while read -r start len; do
      : "${len:=1}"
      [[ "${len}" -eq 0 ]] && continue
      end=$((start + len - 1))
      seq "${start}" "${end}"
    done
}

# Produces a matches line (column format)
match_lines() {
  local blob_sha="$1"
  local search="$2"
  shift 2
  local grep_flags="$@"

  GIT cat-file -p "${blob_sha}" | grep -n ${grep_flags} "${search}" | cut -d: -f1
}

# Produces set of intersected lines (column format)
intersect() {
  local matches_lines="$1"
  local hunks_lines="$2"

  grep -Fxf <(echo -n "${matches_lines}") <(echo -n "${hunks_lines}") || true
}

print_lines() {
  local blob_sha="$1"
  local search="$2"
  local lines="$3"
  local context="$4"
  shift 4;
  local grep_flags="$@"

  local i=0

  echo "${OFFSET} ${blob_sha}"
  echo -n "${lines}" | \
  while read -r line_number || [[ -n "${line_number}" ]]; do
    start=$((line_number - context))
    [[ "${start}" -le 0 ]] && start=1
    end=$((line_number + context))

    [[ $((i++)) -ge 1 ]] && echo "${OFFSET}"

    GIT cat-file -p "${blob_sha}" \
    | nl -ba -w"${OFFSET_LEN}" -s' ' \
    | sed -n "${start},${end}p" \
    | grep --color=always ${grep_flags} "${search}"
  done
}

main() {
  has_flag "--help" "$@" && print_help && exit 0

  local search="$1"; shift
  local ignore_case=
  local word_regexp=
  local context_num=2
  local context="--context=${context_num}"
  local pathspec=

  has_flag "-i" "$@" && ignore_case="--ignore-case"
  has_flag "-w" "$@" && word_regexp="--word-regexp"
  has_flag "-C" "$@" && context_num="$(flag_value "-C" "$@")" && context="--context=${context_num}"
  has_flag "-p" "$@" && pathspec="$(flag_value "-p" "$@" | paste -sd' ' -)"

  local prev_commit
  local prev_filepath=
  local empty_commit="$(GIT hash-object -t tree /dev/null)"
  local l1 l2 lines
  local found= total_files=0 total_found=0

  while IFS=$'\t' read -r commit filepath blob_sha; do
    if [[ "${prev_filepath}" != "${filepath}" ]]; then
       prev_commit="${empty_commit}"
       echo -e "${OFFSET} \e[30;43m${filepath}\e[0m"
       : $((++total_files))
    fi

    l1="$(hunk_lines "${prev_commit}" "${commit}" "${filepath}")"
    l2="$(match_lines "${blob_sha}" "${search}" "${ignore_case}" "${word_regexp}")"
    lines="$(intersect "${l1}" "${l2}")"

    if [[ -n "${lines}" ]]; then
      print_lines "${blob_sha}" "${search}" "${lines}" "${context_num}" "${ignore_case}" "${word_regexp}" "${context}"
      found="$(echo "${lines}" | wc -l | awk '{print $1}')"
      total_found=$((total_found + found))
    fi

    prev_commit="${commit}"
    prev_filepath="${filepath}"
    done < <(grep_commits "${search}" "${pathspec}" "${ignore_case}" "${word_regexp}" \
      | add_blob_sha \
      | group_by_filepath)

    # Calculate stats
    echo "Total files: ${total_files}"
    echo "Total found: ${total_found}"
}

main "$@"
